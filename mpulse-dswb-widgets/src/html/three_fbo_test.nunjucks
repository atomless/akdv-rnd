<!DOCTYPE html>
<html lang="en">
    <head>

        <title>three.js webgl - Multiple Render Targets</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #fff;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                background-color: #000;
                margin: 0px;
                overflow: hidden;
            }
            a {
                color: #B2E9FF;
                font-weight: bold;
                pointer-events: auto;
            }

            canvas {
                position: absolute;
                top: 0;
                left: 0;
            }

            #info {
                pointer-events: none;
                position: absolute;
                left: 0;
                top: 0px; width: 100%;
                padding: 5px;
                display: inline-block;
            }

            #error {
                margin: auto;
                margin-top: 40px;
                display: block;
                max-width: 400px;
                padding: 20px;
                background: #CE0808;
            }
        </style>
        <script id="vs" type="x-shader/x-vertex">
        uniform sampler2D texturePosition;
        uniform float pointSize;
        uniform float sceneSize;
        uniform float time;
        uniform vec3 initColor;
        uniform vec3 fadeolor;

        varying float vAge;
        varying vec3 vColor;
        varying vec3 vLightFront;

        #include <common>
        #include <envmap_pars_vertex>
        #include <bsdfs>
        #include <lights_pars_begin>
        #include <lights_pars_maps>
        #include <color_pars_vertex>
        #include <fog_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {
            #include <color_vertex>
            #include <beginnormal_vertex>

            vec4 textureInfo = texture2D(texturePosition, position.xy);
            vec3 transformed = textureInfo.xyz * sceneSize;
            vec3 transformedNormal = normalMatrix * vec3(normal + normalize(transformed));
            
            vAge = textureInfo.w;
            vColor = initColor;//mix(initColor, fadeolor, smoothstep(0.0, 0.75, vAge));
            gl_PointSize = pointSize * 400.0 * sceneSize;

            #include <project_vertex>
            #include <logdepthbuf_vertex>
            #include <clipping_planes_vertex>

            #include <worldpos_vertex>
            #include <envmap_vertex>
            #include <lights_lambert_vertex>
            #include <shadowmap_vertex>
            #include <fog_vertex>
        }
        </script>        
    </head>
    <body>
        <canvas></canvas>
        <div id="info">
            <div id="error" style="display: none;">
            Your browser does not support <strong>WEBGL_draw_buffers</strong>.<br/><br/>
            This demo will not work.
            </div>
        </div>
        <script>window.akdv = {};</script>
        <script src="../javascript/vendor/three.min.js"></script>
        <script src="../javascript/vendor/three.loaders.obj_loader.js"></script>
        <script src="../javascript/vendor/three.controls.orbit.js"></script>
        <script src="../javascript/vendor/jquery.slim.min.js"></script>
        <script src="../javascript/datajots/utils_three.js"></script>
        <script src="../javascript/datajots/utils_geometry.js"></script>
        <script src="../javascript/datajots/utils_scene.js"></script>
        <script src="../javascript/lib/akdv.utils_env.js"></script>
        <script src="../javascript/lib/_log.js"></script>
        <script src="../javascript/lib/akdv.utils_data.js"></script>
        <script src="../javascript/lib/akdv.xmlHTTP.js"></script>

        <script src="../javascript/datajots/render/lib/particleFBO.js"></script>
        <script src="../javascript/datajots/render/lib/simulationFBO.js"></script>
        <script src="../javascript/vendor/FBOHelper.js"></script>
        <script>
            "use strict";
            const utils_geometry = window.akdv.utils_geometry;
            const utils_scene = window.akdv.utils_scene;

            var camera, scene, renderer, controls;
            var particles, material, simulationFBO;
            var pointLight, sphereMesh;
            var vs = document.getElementById('vs').textContent;

            var THREE = window.THREE;
            var width = 1024;
            var height = 1024;

            init().then(animate);
            
            function init() {

                renderer = new THREE.WebGLRenderer({
                    canvas: document.querySelector('canvas')
                });

                if (!renderer.extensions.get('WEBGL_draw_buffers')) {
                    document.querySelector('#error').style.display = 'block';
                    return;
                }

                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                //renderer.shadowMap.renderSingleSided = false;
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);
                camera.position.set(620, 620, 2020);

                //camera = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 1, 10000)
                //camera.position.z = 1500;

                // controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
               
                // Our scene
                scene = new THREE.Scene();

                onWindowResize();
                window.addEventListener('resize', onWindowResize, false);

                setupLights();
                setupFloor();
                return setupFBO().then(setupScene);
            }

            function setupFBO () {

                return window.akdv.initSimulationFBO({
                    width: width,
                    height: height,
                    format: THREE.RGBFormat,
                    camera: camera,
                    renderer: renderer,
                    vertex_shader_url: '../shaders/ortho.vert',
                    fragment_shader_url: '../shaders/particle_position_morph.frag',
                    uniforms: {
                        textureA: { type: "t", value: null },
                        textureB: { type: "t", value: null },
                        timer: { type: "f", value: 0}
                    }
                }).then((instance) => {
                    simulationFBO = instance;

                    //var dataA = utils_geometry.loadObjMesh("../javascript/datajots/bulb.obj", 1).then((data) => simulationFBO.addDataTextureUniform('textureA', data));
                    var data_size = width * height * 3;
                    var dataA = utils_geometry.pointCloudRandomData(new Float32Array(data_size), 800);
                    simulationFBO.addDataTextureUniform('textureA', dataA);
                    var dataB = utils_geometry.pointCloudSphere(new Float32Array(data_size), 800);
                    simulationFBO.addDataTextureUniform('textureB', dataB);
                })

            }

            function setupScene () {


                return window.akdv.initParticleFBO({
                    width: width,
                    height: height,
                    scene_scale: 1,
                    render_camera: camera,
                    simulationFBO: simulationFBO,
                    particle_fragment_shader_url: '../shaders/particle_render.frag'
                }).then((instance) => {

                    particles = instance;
                    scene.add(particles.container);
                });             
            }

            function setupLights() {

                const light_rig = utils_scene.createThreePointLightRig({
                    ambient_intensity: 0.3,
                    key_position: new THREE.Vector3(3000, 2000, 3000),
                    key_rotation: new THREE.Vector3(THREE.Math.degToRad(-45), 0, 0),
                    key_color: new THREE.Color('hsl(30, 100%, 91%)'),
                    key_intensity: 3,
                    cast_shadow: true,
                    fill1_position: new THREE.Vector3(4000, 1500, -3000),
                    fill1_rotation: new THREE.Vector3(THREE.Math.degToRad(-10), 0, 0),
                    fill1_color: new THREE.Color('hsl(215, 25%, 90%)'),
                    fill1_intensity: 0.275,
                    fill2_position: new THREE.Vector3(-4000, -2000, -3000),
                    fill2_rotation: new THREE.Vector3(THREE.Math.degToRad(-15), 0, 0),
                    fill2_color: new THREE.Color('hsl(190, 25%, 90%)'),
                    fill2_intensity: 0.225
                });

                scene.add(light_rig.rig);
            }

            function setupFloor() {

                var geometry = new THREE.PlaneGeometry(14000, 14000, 10, 10);
                var metalMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(0.95, 0.975, 1, 0.9),
                    shininess: 1
                });

                var floor = new THREE.Mesh(geometry, metalMaterial);
                floor.rotation.x = THREE.Math.degToRad(-90);
                floor.position.y = -800;
                floor.castShadow = false;
                floor.receiveShadow = true;

                scene.add(floor);

                var sphere = new THREE.IcosahedronGeometry(200, 3);
  
                sphereMesh = new THREE.Mesh(sphere, metalMaterial);
                sphereMesh.position.y = 250;
                sphereMesh.position.x = -2000;
                sphereMesh.position.z = -2000;
                sphereMesh.castShadow = true;
                sphereMesh.receiveShadow = true;
                sphereMesh.renderOrder = 1;            
                
                scene.add(sphereMesh);
            }

            function onWindowResize() {

                var aspect = window.innerWidth / window.innerHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();

                var dpr = renderer.getPixelRatio();
                renderer.setSize(window.innerWidth, window.innerHeight);

            }

            function animate() {

                simulationFBO.uniforms.timer.value = Math.sin(parseFloat((performance.now() * 0.0005)));
                particles.container.rotation.y -= Math.PI / 180 * 0.1;
                sphereMesh.position.z = sphereMesh.position.x = simulationFBO.uniforms.timer.value * 1000;

                simulationFBO.tick();
                particles.tick();

                controls.update();
                renderer.render(scene, camera);

                requestAnimationFrame(animate);
            }         

        </script>

    </body>
</html>